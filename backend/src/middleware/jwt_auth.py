"""
JWT authentication middleware for Better Auth tokens.

This middleware verifies JWT tokens generated by the Better Auth TypeScript service,
allowing FastAPI routes to authenticate users without FastAPI-Users.

Usage:
    from src.middleware.jwt_auth import get_current_user

    @router.get("/profile")
    async def get_profile(user: User = Depends(get_current_user)):
        return {"user_id": user.id, "email": user.email}
"""

import jwt
from datetime import datetime
from typing import Optional
from uuid import UUID
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from ..config import settings
from ..database import get_async_session
from ..models.user import User

# HTTP Bearer token scheme
bearer_scheme = HTTPBearer(auto_error=False)


async def verify_jwt_token(token: str) -> dict:
    """
    Verify Better Auth JWT token using shared JWT_SECRET.

    Args:
        token: JWT token string from Authorization header

    Returns:
        dict: Decoded token payload containing user_id

    Raises:
        HTTPException: If token is invalid, expired, or malformed
    """
    try:
        # Decode and verify JWT
        payload = jwt.decode(
            token,
            settings.jwt_secret,  # MUST match auth-ts JWT_SECRET exactly
            algorithms=["HS256"],
        )

        # Check expiration (JWT library handles this, but explicit check for clarity)
        if "exp" in payload:
            exp_timestamp = payload["exp"]
            if datetime.fromtimestamp(exp_timestamp) < datetime.now():
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Token has expired",
                    headers={"WWW-Authenticate": "Bearer"},
                )

        # Extract user_id (Better Auth uses 'userId' or 'sub')
        user_id = payload.get("userId") or payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token: missing user_id",
                headers={"WWW-Authenticate": "Bearer"},
            )

        return {"user_id": user_id, "payload": payload}

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.InvalidTokenError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid token: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"},
        )


async def get_current_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme),
    session: AsyncSession = Depends(get_async_session),
) -> User:
    """
    FastAPI dependency to get current authenticated user from Better Auth JWT.

    This replaces the FastAPI-Users `current_verified_user` dependency.

    Args:
        credentials: Bearer token from Authorization header
        session: Database session

    Returns:
        User: Authenticated user object from database

    Raises:
        HTTPException: If token is missing, invalid, or user not found

    Usage:
        @router.get("/protected")
        async def protected_route(user: User = Depends(get_current_user)):
            return {"user_id": str(user.id), "email": user.email}
    """
    if not credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing authentication token",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Verify JWT token
    token_data = await verify_jwt_token(credentials.credentials)
    user_id = UUID(token_data["user_id"])

    # Fetch user from database
    result = await session.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )

    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is inactive",
        )

    return user


async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer_scheme),
    session: AsyncSession = Depends(get_async_session),
) -> Optional[User]:
    """
    Optional authentication dependency - returns None if no token provided.

    Use for routes that work differently for authenticated vs anonymous users.

    Args:
        credentials: Bearer token from Authorization header (optional)
        session: Database session

    Returns:
        User | None: Authenticated user if valid token, None otherwise
    """
    if not credentials:
        return None

    try:
        return await get_current_user(credentials, session)
    except HTTPException:
        return None
